#!/bin/bash

# CakePHP Documentation RST to Markdown Converter
# Usage: ./convert <input_dir> <output_dir>

set -e

# Allow custom pandoc binary path via environment variable
PANDOC_BIN="${PANDOC_BIN:-pandoc}"

# Resolve to absolute path if it's a relative path
if [[ "$PANDOC_BIN" != /* ]] && [[ "$PANDOC_BIN" != "pandoc" ]]; then
    PANDOC_BIN="$(cd "$(dirname "$PANDOC_BIN")" && pwd)/$(basename "$PANDOC_BIN")"
fi

# Check if pandoc is installed
if ! command -v "$PANDOC_BIN" &> /dev/null; then
    echo "Error: pandoc is required but not installed."
    echo "Please install pandoc 3.x or later."
    echo "Or set PANDOC_BIN environment variable to point to your pandoc binary."
    exit 1
fi

# Check arguments
if [ "$#" -ne 2 ]; then
    echo "Usage: $0 <input_dir> <output_dir>"
    echo "Example: $0 legacy/en docs/en"
    exit 1
fi

INPUT_DIR="$1"
OUTPUT_DIR="$2"

# Validate input directory
if [ ! -d "$INPUT_DIR" ]; then
    echo "Error: Input directory '$INPUT_DIR' does not exist."
    exit 1
fi

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Get the absolute path of the script directory for filters
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FILTERS_DIR="$SCRIPT_DIR/pandoc_filters"

# Create filters directory if it doesn't exist
mkdir -p "$FILTERS_DIR"

# Set environment variables for substitutions
export PHPVERSION="8.4"
export MINPHPVERSION="8.1"

echo "Converting RST documentation from $INPUT_DIR to $OUTPUT_DIR..."
echo "Using filters from: $FILTERS_DIR"

# Find all .rst files and convert them
find "$INPUT_DIR" -name "*.rst" -type f | while read -r rst_file; do
    # Get relative path from input directory
    rel_path="${rst_file#$INPUT_DIR/}"
    
    # Create output path with .md extension
    md_file="$OUTPUT_DIR/${rel_path%.rst}.md"
    
    # Create output directory structure
    mkdir -p "$(dirname "$md_file")"
    
    echo "Converting: $rel_path"
    
    # Create a temporary file with substitutions and include path fixes applied
    temp_file=$(mktemp)
    
    # Pre-process the RST file to handle substitutions, PHP directives, and fix include paths
    # Preserve version variables as literal text for markdown-it processing
    # Note: Order matters - process minphpversion first to avoid partial matches
    sed -e "s/|minphpversion|/MINPHPVERSION_MARKER/g" \
        -e "s/|phpversion|/PHPVERSION_MARKER/g" \
        "$rst_file" | \
    python3 -c "
import re
import sys

def fix_include_paths(content):
    lines = content.split('\n')
    result_lines = []
    
    for line in lines:
        # Check if this is an include directive with absolute path
        include_match = re.match(r'^(\s*\.\. include::\s*)(/.*)', line)
        if include_match:
            indent = include_match.group(1)
            absolute_path = include_match.group(2)
            # Convert absolute path to relative path (remove leading slash)
            relative_path = absolute_path[1:]
            line = indent + relative_path
            
        result_lines.append(line)
    
    return '\n'.join(result_lines)

def fix_literal_blocks_in_directives(content):
    \"\"\"
    Convert literal blocks (::) inside directives (note, warning, etc.) 
    into explicit code-block directives so Pandoc preserves them as code.
    \"\"\"
    lines = content.split('\n')
    result = []
    i = 0
    
    while i < len(lines):
        line = lines[i]
        
        # Check if this is a directive (note, warning, tip, etc.)
        directive_match = re.match(r'^(\s*)\.\.\s+(note|warning|tip|important|caution|danger|attention|hint|seealso|admonition)::\s*(.*)$', line)
        
        if directive_match:
            indent = directive_match.group(1)
            directive_type = directive_match.group(2)
            directive_args = directive_match.group(3)
            
            # Add the directive line
            result.append(line)
            i += 1
            
            # Expected content indentation (directive indent + 4 spaces)
            content_indent = indent + '    '
            
            # Process the content of the directive
            while i < len(lines):
                current_line = lines[i]
                
                # Check if we've left the directive (dedented or empty line at directive level)
                if current_line.strip() and not current_line.startswith(content_indent):
                    # We've left the directive
                    break
                
                # Check if this line ends with :: (literal block marker)
                if current_line.rstrip().endswith('::') and current_line.strip() != '::':
                    # This is a literal block marker
                    # Remove the :: and add it as regular text
                    result.append(current_line[:-1])  # Remove the trailing :
                    i += 1
                    
                    # Skip any blank lines
                    while i < len(lines) and not lines[i].strip():
                        result.append(lines[i])
                        i += 1
                    
                    # Now we should have the code block
                    # Expected code indent is content_indent + 4 more spaces
                    code_indent = content_indent + '    '
                    
                    if i < len(lines) and lines[i].startswith(code_indent):
                        # We have a code block - determine the language
                        # Look at multiple lines to guess the language more accurately
                        first_code_line = lines[i].strip()
                        # Look ahead at more lines for better detection
                        code_sample = []
                        temp_i = i
                        while temp_i < len(lines) and temp_i < i + 10 and (lines[temp_i].startswith(code_indent) or not lines[temp_i].strip()):
                            if lines[temp_i].strip():
                                code_sample.append(lines[temp_i].strip())
                            temp_i += 1
                        
                        code_text = ' '.join(code_sample).lower()
                        language = 'php'  # default to php for CakePHP docs
                        
                        # Detect bash/shell commands
                        if first_code_line.startswith('bin/cake') or first_code_line.startswith('composer') or first_code_line.startswith('$') or first_code_line.startswith('user@'):
                            language = 'bash'
                        # Detect SQL
                        elif first_code_line.startswith('SELECT') or first_code_line.startswith('CREATE') or first_code_line.startswith('INSERT') or first_code_line.startswith('UPDATE') or first_code_line.startswith('DELETE'):
                            language = 'sql'
                        # PHP is already the default, but let's be explicit about strong indicators
                        elif first_code_line.startswith('<?php') or 'namespace' in code_text or '->' in code_text or '::' in code_text or first_code_line.startswith('class ') or first_code_line.startswith('public ') or first_code_line.startswith('private ') or first_code_line.startswith('protected '):
                            language = 'php'
                        
                        # Add explicit code-block directive
                        result.append('')
                        result.append(content_indent + '.. code-block:: ' + language)
                        result.append('')
                        
                        # Add all the code lines with proper indentation
                        # Code blocks in RST need to be indented relative to the directive
                        code_block_indent = content_indent + '    '
                        while i < len(lines) and (lines[i].startswith(code_indent) or not lines[i].strip()):
                            if lines[i].strip():
                                # Keep the original code indentation but adjust the base
                                # Remove code_indent and add code_block_indent
                                code_content = lines[i][len(code_indent):]
                                result.append(code_block_indent + code_content)
                            else:
                                result.append(lines[i])
                            i += 1
                        
                        continue
                
                # Regular line in directive
                result.append(current_line)
                i += 1
        else:
            # Not a directive, just add the line
            result.append(line)
            i += 1
    
    return '\n'.join(result)

# Read from stdin
content = sys.stdin.read()
# Fix include paths
fixed_content = fix_include_paths(content)
# Fix literal blocks in directives
fixed_content = fix_literal_blocks_in_directives(fixed_content)
# Output the result
sys.stdout.write(fixed_content)
" | \
    awk '
    BEGIN { namespace = ""; class = "" }
    
    # Capture namespace
    /^.. php:namespace::/ {
        namespace = $3
        next
    }
    
    # Capture class and format it
    /^.. php:class::/ {
        # Get everything after ".. php:class:: "
        class_line = $0
        gsub(/^.. php:class:: /, "", class_line)

        # Parse class name and constructor parameters
        if (match(class_line, /^([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*)\)\s*$/, arr)) {
            class = arr[1]
            params = arr[2]
        } else {
            # No constructor parameters, just the class name
            class = class_line
            params = ""
        }

        if (namespace != "") {
            print ""
            print ".. raw:: html"
            print ""
            if (params != "") {
                print "   <code>class " namespace "\\<strong>" class "</strong>(" params ")</code>"
            } else {
                print "   <code>class " namespace "\\<strong>" class "</strong></code>"
            }
            print ""
        } else {
            print ""
            print ".. raw:: html"
            print ""
            if (params != "") {
                print "   <code>class <strong>" class "</strong>(" params ")</code>"
            } else {
                print "   <code>class <strong>" class "</strong></code>"
            }
            print ""
        }
        next
    }
    
    # Handle method directives
    /^.. php:method::/ {
        # Get everything after ".. php:method:: "
        method_line = $0
        gsub(/^.. php:method:: /, "", method_line)
        
        # Parse method name and parameters
        if (match(method_line, /^([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*)\)\s*$/, arr)) {
            method_name = arr[1]
            params = arr[2]
        } else if (match(method_line, /^([a-zA-Z_][a-zA-Z0-9_]*)\s*$/, arr)) {
            method_name = arr[1]
            params = ""
        } else {
            # Fallback - treat the whole thing as method name
            method_name = method_line
            params = ""
        }
        
        # Build full class name
        if (namespace != "" && class != "") {
            full_class = namespace "\\" class
        } else if (class != "") {
            full_class = class
        } else {
            full_class = "Class"
        }
        
        # Format method using raw HTML
        print ""
        print ".. raw:: html"
        print ""
        if (params != "") {
            print "   <code>method " full_class "::<strong>" method_name "</strong>(" params ")</code>"
        } else {
            print "   <code>method " full_class "::<strong>" method_name "</strong>()</code>"
        }
        print ""
        next
    }
    
    # Handle static method directives
    /^.. php:staticmethod::/ {
        # Get everything after ".. php:staticmethod:: "
        static_line = $0
        gsub(/^.. php:staticmethod:: /, "", static_line)
        
        # Parse the signature to separate method name from arguments
        method_name = ""
        params = ""
        class_prefix = ""
        
        # Check if line already has class prefix
        if (match(static_line, /^([a-zA-Z_][a-zA-Z0-9_\\]*)::/)) {
            # Extract existing class prefix
            class_prefix = substr(static_line, 1, RLENGTH - 2)
            static_line = substr(static_line, RLENGTH + 1)
        } else {
            # Build class prefix from context
            if (namespace != "" && class != "") {
                class_prefix = namespace "\\" class
            } else if (class != "") {
                class_prefix = class
            } else {
                class_prefix = "Class"
            }
        }
        
        # Parse method name and parameters
        if (match(static_line, /^([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*)\)\s*$/)) {
            method_name = substr(static_line, 1, RLENGTH)
            gsub(/\(.*$/, "", method_name)
            params = substr(static_line, length(method_name) + 1)
        } else {
            method_name = static_line
            params = "()"
        }
        
        # Output as directive that Pandoc will process, keeping description attached
        # Escape backslashes for RST so Pandoc preserves them
        gsub(/\\/, "\\\\\\\\", class_prefix)
        
        print ""
        print ".. php-static-def:: " class_prefix "::" method_name params
        next
    }
    
    # Handle function directives  
    /^.. php:function::/ {
        # Get everything after ".. php:function:: "
        func_line = $0
        gsub(/^.. php:function:: /, "", func_line)
        
        # Functions do not need namespace prefix - just the function name
        # Output as directive that Pandoc will process, keeping description attached
        print ""
        print ".. php-function-def:: " func_line
        next
    }
    
    # Handle constant directives
    /^.. php:const::/ {
        # Get everything after ".. php:const:: "
        const_line = $0
        gsub(/^.. php:const:: /, "", const_line)
        
        # Build namespace prefix with escaped backslashes for RST
        ns_prefix = ""
        if (namespace != "") {
            # Use double backslashes so Pandoc preserves them
            ns_prefix = namespace
            gsub(/\\/, "\\\\\\\\", ns_prefix)
            ns_prefix = ns_prefix "\\\\"
        }
        
        # Output as directive that Pandoc will process, keeping description attached
        print ""
        print ".. php-const-def:: " ns_prefix const_line
        next
    }
    
    # Remove other PHP directives we do not handle
    /^.. php:/ { next }
    
    # Print all other lines
    { print }
    ' > "$temp_file"
    
    # Get the directory of the input file for include resolution
    rst_dir=$(dirname "$rst_file")
    
    # Copy temp file to the RST directory for include resolution
    temp_in_rst_dir="$rst_dir/$(basename "$temp_file").rst"
    cp "$temp_file" "$temp_in_rst_dir"
    
    # Get absolute path for output
    md_file_abs="$(cd "$(dirname "$md_file")" && pwd)/$(basename "$md_file")"

    # Set destination context and folder for the Lua filter (use absolute paths)
    export DESTINATION_CONTEXT="$md_file_abs"
    export DESTINATION_FOLDER="$(cd "$OUTPUT_DIR" && pwd)"
    export SOURCE_FOLDER="$(cd "$INPUT_DIR" && pwd)"
    export CURRENT_SOURCE_FILE="$rst_file"

    # Change to RST directory and run pandoc for proper include resolution
    (cd "$rst_dir" && \
    DESTINATION_CONTEXT="$DESTINATION_CONTEXT" \
    DESTINATION_FOLDER="$DESTINATION_FOLDER" \
    SOURCE_FOLDER="$SOURCE_FOLDER" \
    CURRENT_SOURCE_FILE="$CURRENT_SOURCE_FILE" \
    "$PANDOC_BIN" \
        --from=rst \
        --to=gfm \
        --wrap=preserve \
        --lua-filter="$FILTERS_DIR/meta.lua" \
        --lua-filter="$FILTERS_DIR/doc_links.lua" \
        --lua-filter="$FILTERS_DIR/ref.lua" \
        --lua-filter="$FILTERS_DIR/php_domain.lua" \
        --lua-filter="$FILTERS_DIR/php_definitions.lua" \
        --lua-filter="$FILTERS_DIR/fqdn_cleanup.lua" \
        --lua-filter="$FILTERS_DIR/url_anchor_cleanup.lua" \
        --lua-filter="$FILTERS_DIR/containers.lua" \
        --lua-filter="$FILTERS_DIR/versionadded.lua" \
        --lua-filter="$FILTERS_DIR/language.lua" \
        --lua-filter="$FILTERS_DIR/images.lua" \
        --lua-filter="$FILTERS_DIR/toctree.lua" \
        --lua-filter="$FILTERS_DIR/table_cleanup.lua" \
        --lua-filter="$FILTERS_DIR/anchors.lua" \
        --lua-filter="$FILTERS_DIR/codeblocks.lua" \
        --output="$md_file_abs" \
        "$(basename "$temp_in_rst_dir")")

    # Post-process the markdown file to restore version variables
    sed -i -e "s/MINPHPVERSION_MARKER/|minphpversion|/g" \
           -e "s/PHPVERSION_MARKER/|phpversion|/g" \
           "$md_file_abs"

    # Post-process tables to fix multi-line cells
    # GFM tables don't support multi-line cells, so we need to collapse continuation lines
    python3 <<'EOF' - "$md_file_abs"
import sys
import re

def fix_table_continuations(content):
    lines = content.split('\n')
    result = []
    i = 0
    in_code_block = False
    
    while i < len(lines):
        line = lines[i]
        
        # Track code block boundaries
        if line.strip().startswith('```'):
            in_code_block = not in_code_block
            result.append(line)
            i += 1
            continue
        
        # Skip processing if we're inside a code block
        if in_code_block:
            result.append(line)
            i += 1
            continue
        
        # Check if this is a table row (contains | and has content)
        if '|' in line and line.strip():
            # Collect all continuation lines
            full_line = line
            
            while i + 1 < len(lines):
                next_line = lines[i + 1]
                
                # Don't process continuation if next line is a code fence
                if next_line.strip().startswith('```'):
                    break
                
                # Check if next line is a continuation
                # Continuation: doesn't start with |, OR starts with just spaces/period and ends with |
                is_continuation = False
                
                if next_line.strip():
                    # Line is not empty
                    if not next_line.lstrip().startswith('|'):
                        # Doesn't start with | after stripping leading spaces
                        # But make sure it's not a quote block or other markdown
                        if not next_line.lstrip().startswith('>') and not next_line.lstrip().startswith('#'):
                            is_continuation = True
                    elif next_line.strip().startswith('.') and next_line.strip().endswith('|'):
                        # Special case: ". |" continuation pattern
                        is_continuation = True
                
                if is_continuation:
                    # This is a continuation line
                    continuation_text = next_line.strip()
                    
                    # Remove trailing | if it exists in continuation
                    if continuation_text.endswith('|'):
                        continuation_text = continuation_text[:-1].strip()
                    
                    # Remove leading period if it exists
                    if continuation_text.startswith('.'):
                        continuation_text = continuation_text[1:].strip()
                    
                    # Merge with the previous line
                    # Remove trailing spaces and | from current line, add continuation, add | back
                    if full_line.rstrip().endswith('|'):
                        full_line = full_line.rstrip()[:-1].rstrip() + ' ' + continuation_text + ' |'
                    else:
                        full_line = full_line.rstrip() + ' ' + continuation_text
                    
                    i += 1
                else:
                    break
            
            result.append(full_line)
        else:
            result.append(line)
        
        i += 1
    
    return '\n'.join(result)

if __name__ == '__main__':
    filename = sys.argv[1]
    with open(filename, 'r', encoding='utf-8') as f:
        content = f.read()
    
    fixed_content = fix_table_continuations(content)
    
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(fixed_content)
EOF

    # Clean up temp file in RST directory
    rm -f "$temp_in_rst_dir"
    
    # Clean up temp file
    rm "$temp_file"
done

echo "Conversion completed!"
echo "Converted files are in: $OUTPUT_DIR"