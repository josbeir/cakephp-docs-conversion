#!/bin/bash

# CakePHP Documentation RST to Markdown Converter
# Usage: ./convert <input_dir> <output_dir>

set -e

# Allow custom pandoc binary path via environment variable
PANDOC_BIN="${PANDOC_BIN:-pandoc}"

# Resolve to absolute path if it's a relative path
if [[ "$PANDOC_BIN" != /* ]] && [[ "$PANDOC_BIN" != "pandoc" ]]; then
    PANDOC_BIN="$(cd "$(dirname "$PANDOC_BIN")" && pwd)/$(basename "$PANDOC_BIN")"
fi

# Check if pandoc is installed
if ! command -v "$PANDOC_BIN" &> /dev/null; then
    echo "Error: pandoc is required but not installed."
    echo "Please install pandoc 3.x or later."
    echo "Or set PANDOC_BIN environment variable to point to your pandoc binary."
    exit 1
fi

# Check arguments
if [ "$#" -ne 2 ]; then
    echo "Usage: $0 <input_dir> <output_dir>"
    echo "Example: $0 legacy/en docs/en"
    exit 1
fi

INPUT_DIR="$1"
OUTPUT_DIR="$2"

# Validate input directory
if [ ! -d "$INPUT_DIR" ]; then
    echo "Error: Input directory '$INPUT_DIR' does not exist."
    exit 1
fi

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Get the absolute path of the script directory for filters
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FILTERS_DIR="$SCRIPT_DIR/pandoc_filters"

# Create filters directory if it doesn't exist
mkdir -p "$FILTERS_DIR"

# Set environment variables for substitutions
export PHPVERSION="8.4"
export MINPHPVERSION="8.1"

echo "Converting RST documentation from $INPUT_DIR to $OUTPUT_DIR..."
echo "Using filters from: $FILTERS_DIR"

# Find all .rst files and convert them
find "$INPUT_DIR" -name "*.rst" -type f | while read -r rst_file; do
    # Get relative path from input directory
    rel_path="${rst_file#$INPUT_DIR/}"
    
    # Create output path with .md extension
    md_file="$OUTPUT_DIR/${rel_path%.rst}.md"
    
    # Create output directory structure
    mkdir -p "$(dirname "$md_file")"
    
    echo "Converting: $rel_path"
    
    # Create a temporary file with substitutions and include path fixes applied
    temp_file=$(mktemp)
    
    # Pre-process the RST file to handle substitutions, PHP directives, and fix include paths
    # Preserve version variables as literal text for markdown-it processing
    # Note: Order matters - process minphpversion first to avoid partial matches
    sed -e "s/|minphpversion|/MINPHPVERSION_MARKER/g" \
        -e "s/|phpversion|/PHPVERSION_MARKER/g" \
        "$rst_file" | \
    python3 -c "
import re
import sys

def fix_include_paths(content):
    lines = content.split('\n')
    result_lines = []
    
    for line in lines:
        # Check if this is an include directive with absolute path
        include_match = re.match(r'^(\s*\.\. include::\s*)(/.*)', line)
        if include_match:
            indent = include_match.group(1)
            absolute_path = include_match.group(2)
            # Convert absolute path to relative path (remove leading slash)
            relative_path = absolute_path[1:]
            line = indent + relative_path
            
        result_lines.append(line)
    
    return '\n'.join(result_lines)

# Read from stdin
content = sys.stdin.read()
# Fix include paths
fixed_content = fix_include_paths(content)
# Output the result
sys.stdout.write(fixed_content)
" | \
    awk '
    BEGIN { namespace = ""; class = "" }
    
    # Capture namespace
    /^.. php:namespace::/ {
        namespace = $3
        next
    }
    
    # Capture class and format it
    /^.. php:class::/ {
        # Get everything after ".. php:class:: "
        class_line = $0
        gsub(/^.. php:class:: /, "", class_line)

        # Parse class name and constructor parameters
        if (match(class_line, /^([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*)\)\s*$/, arr)) {
            class = arr[1]
            params = arr[2]
        } else {
            # No constructor parameters, just the class name
            class = class_line
            params = ""
        }

        if (namespace != "") {
            print ""
            print ".. raw:: html"
            print ""
            if (params != "") {
                print "   <code>class " namespace "\\<strong>" class "</strong>(" params ")</code>"
            } else {
                print "   <code>class " namespace "\\<strong>" class "</strong></code>"
            }
            print ""
        } else {
            print ""
            print ".. raw:: html"
            print ""
            if (params != "") {
                print "   <code>class <strong>" class "</strong>(" params ")</code>"
            } else {
                print "   <code>class <strong>" class "</strong></code>"
            }
            print ""
        }
        next
    }
    
    # Handle method directives
    /^.. php:method::/ {
        # Get everything after ".. php:method:: "
        method_line = $0
        gsub(/^.. php:method:: /, "", method_line)
        
        # Parse method name and parameters
        if (match(method_line, /^([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*)\)\s*$/, arr)) {
            method_name = arr[1]
            params = arr[2]
        } else if (match(method_line, /^([a-zA-Z_][a-zA-Z0-9_]*)\s*$/, arr)) {
            method_name = arr[1]
            params = ""
        } else {
            # Fallback - treat the whole thing as method name
            method_name = method_line
            params = ""
        }
        
        # Build full class name
        if (namespace != "" && class != "") {
            full_class = namespace "\\" class
        } else if (class != "") {
            full_class = class
        } else {
            full_class = "Class"
        }
        
        # Format method using raw HTML
        print ""
        print ".. raw:: html"
        print ""
        if (params != "") {
            print "   <code>method " full_class "::<strong>" method_name "</strong>(" params ")</code>"
        } else {
            print "   <code>method " full_class "::<strong>" method_name "</strong>()</code>"
        }
        print ""
        next
    }
    
    # Remove other PHP directives we do not handle
    /^.. php:/ { next }
    
    # Print all other lines
    { print }
    ' > "$temp_file"
    
    # Get the directory of the input file for include resolution
    rst_dir=$(dirname "$rst_file")
    
    # Copy temp file to the RST directory for include resolution
    temp_in_rst_dir="$rst_dir/$(basename "$temp_file").rst"
    cp "$temp_file" "$temp_in_rst_dir"
    
    # Get absolute path for output
    md_file_abs="$(cd "$(dirname "$md_file")" && pwd)/$(basename "$md_file")"

    # Set destination context and folder for the Lua filter (use absolute paths)
    export DESTINATION_CONTEXT="$md_file_abs"
    export DESTINATION_FOLDER="$(cd "$OUTPUT_DIR" && pwd)"
    export SOURCE_FOLDER="$(cd "$INPUT_DIR" && pwd)"
    export CURRENT_SOURCE_FILE="$rst_file"

    # Change to RST directory and run pandoc for proper include resolution
    (cd "$rst_dir" && \
    DESTINATION_CONTEXT="$DESTINATION_CONTEXT" \
    DESTINATION_FOLDER="$DESTINATION_FOLDER" \
    SOURCE_FOLDER="$SOURCE_FOLDER" \
    CURRENT_SOURCE_FILE="$CURRENT_SOURCE_FILE" \
    "$PANDOC_BIN" \
        --from=rst \
        --to=gfm \
        --wrap=preserve \
        --lua-filter="$FILTERS_DIR/meta.lua" \
        --lua-filter="$FILTERS_DIR/doc_links.lua" \
        --lua-filter="$FILTERS_DIR/ref.lua" \
        --lua-filter="$FILTERS_DIR/php_domain.lua" \
        --lua-filter="$FILTERS_DIR/fqdn_cleanup.lua" \
        --lua-filter="$FILTERS_DIR/url_anchor_cleanup.lua" \
        --lua-filter="$FILTERS_DIR/containers.lua" \
        --lua-filter="$FILTERS_DIR/versionadded.lua" \
        --lua-filter="$FILTERS_DIR/language.lua" \
        --lua-filter="$FILTERS_DIR/images.lua" \
        --lua-filter="$FILTERS_DIR/toctree.lua" \
        --lua-filter="$FILTERS_DIR/table_cleanup.lua" \
        --lua-filter="$FILTERS_DIR/anchors.lua" \
        --lua-filter="$FILTERS_DIR/codeblocks.lua" \
        --output="$md_file_abs" \
        "$(basename "$temp_in_rst_dir")")

    # Post-process the markdown file to restore version variables
    sed -i -e "s/MINPHPVERSION_MARKER/|minphpversion|/g" \
           -e "s/PHPVERSION_MARKER/|phpversion|/g" \
           "$md_file_abs"

    # Post-process tables to fix multi-line cells
    # GFM tables don't support multi-line cells, so we need to collapse continuation lines
    python3 <<'EOF' - "$md_file_abs"
import sys
import re

def fix_table_continuations(content):
    lines = content.split('\n')
    result = []
    i = 0
    in_code_block = False
    
    while i < len(lines):
        line = lines[i]
        
        # Track code block boundaries
        if line.strip().startswith('```'):
            in_code_block = not in_code_block
            result.append(line)
            i += 1
            continue
        
        # Skip processing if we're inside a code block
        if in_code_block:
            result.append(line)
            i += 1
            continue
        
        # Check if this is a table row (contains | and has content)
        if '|' in line and line.strip():
            # Collect all continuation lines
            full_line = line
            
            while i + 1 < len(lines):
                next_line = lines[i + 1]
                
                # Don't process continuation if next line is a code fence
                if next_line.strip().startswith('```'):
                    break
                
                # Check if next line is a continuation
                # Continuation: doesn't start with |, OR starts with just spaces/period and ends with |
                is_continuation = False
                
                if next_line.strip():
                    # Line is not empty
                    if not next_line.lstrip().startswith('|'):
                        # Doesn't start with | after stripping leading spaces
                        # But make sure it's not a quote block or other markdown
                        if not next_line.lstrip().startswith('>') and not next_line.lstrip().startswith('#'):
                            is_continuation = True
                    elif next_line.strip().startswith('.') and next_line.strip().endswith('|'):
                        # Special case: ". |" continuation pattern
                        is_continuation = True
                
                if is_continuation:
                    # This is a continuation line
                    continuation_text = next_line.strip()
                    
                    # Remove trailing | if it exists in continuation
                    if continuation_text.endswith('|'):
                        continuation_text = continuation_text[:-1].strip()
                    
                    # Remove leading period if it exists
                    if continuation_text.startswith('.'):
                        continuation_text = continuation_text[1:].strip()
                    
                    # Merge with the previous line
                    # Remove trailing spaces and | from current line, add continuation, add | back
                    if full_line.rstrip().endswith('|'):
                        full_line = full_line.rstrip()[:-1].rstrip() + ' ' + continuation_text + ' |'
                    else:
                        full_line = full_line.rstrip() + ' ' + continuation_text
                    
                    i += 1
                else:
                    break
            
            result.append(full_line)
        else:
            result.append(line)
        
        i += 1
    
    return '\n'.join(result)

if __name__ == '__main__':
    filename = sys.argv[1]
    with open(filename, 'r', encoding='utf-8') as f:
        content = f.read()
    
    fixed_content = fix_table_continuations(content)
    
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(fixed_content)
EOF

    # Clean up temp file in RST directory
    rm -f "$temp_in_rst_dir"
    
    # Clean up temp file
    rm "$temp_file"
done

echo "Conversion completed!"
echo "Converted files are in: $OUTPUT_DIR"